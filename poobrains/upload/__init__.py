# -*- coding: utf-8 -*-

import os
import collections
import peewee
import werkzeug
import jinja2
import flask
import poobrains

class UploadForm(poobrains.form.AddForm):
   
    upload = poobrains.form.fields.File()
    filename = poobrains.form.fields.Value()
    force = poobrains.form.fields.Checkbox(label='Rename file if exists')


    def __init__(self, *args, **kwargs):

        super(UploadForm, self).__init__(*args, **kwargs)

        if self.mode == 'add':
            self.fields['upload'].required = True


    def bind(self, values, files):

        super(UploadForm, self).bind(values, files)
        
        upload_file = self.fields['upload'].value
        self.fields['filename'].value = werkzeug.utils.secure_filename(upload_file.filename)

        extension = self.fields['filename'].value.split('.')[-1]

        if  not '*' in self.instance.extension_whitelist and\
        upload_file.filename != '' and\
        not extension in self.instance.extension_whitelist:
            raise poobrains.form.errors.CompoundError(
                [poobrains.form.errors.ValidationError(
                    'Invalid file extension: %s. Try one of %s.' % (extension, list(self.instance.extension_whitelist))
                )]
            )


    def handle(self):
        
        force = self.fields['force'].value
        upload_file = self.fields['upload'].value
        filename = self.fields['filename'].value

        if filename is not '':

            file_path = os.path.join(self.instance.path, filename)

            if os.path.exists(file_path) and self.mode == 'add':

                if force:
                    extension = self.fields['filename'].value.split('.')[-1]
                    filename = '%s.%s' % (self.fields['name'].value, extension) # name field autogenerated and filled by AddForm
                    self.fields['filename'].value = filename # needed so that super call fills in the right name
                    file_path = os.path.join(self.instance.path, filename)

                else:
                    try:
                        conflict = self.model.select().where(self.model.filename == filename).get()
                        flask.flash(jinja2.Markup(u'A file already exists at the same place on the filesystem. See if <a href="%s">%s</a> is the same file.' % (conflict.url('raw'), conflict.name)))

                    except self.model.DoesNotExist:
                        
                        flask.flash('A file unknown to this site already exists at the same place on the filesystem. /dev/null has been informed.')
                        poobrains.app.logger.error('Unknown file clutter: %s/upload/%s/%s' % (poobrains.app.root_path, self.instance.path, filename))

                    return self

            try:
                upload_file.save(file_path)

            except IOError as e:

                flask.flash(u"Failed saving file '%s'." % filename, 'error')
                poobrains.app.logger.error(u"Failed saving file: %s\n%s: %s / %s / %s" % (filename, type(e).__name__, e.message, e.strerror, e.filename))
                return self # stop handling, show form within same request

        try:
            return super(UploadForm, self).handle(exceptions=True)

        except peewee.DatabaseError as e:
            flask.flash(u"Could not save file metadata for file '%s'. Deleting file, sorry if it was big. ¯\_(ツ)_/¯" % filename)
            flask.flash(e.message)
            poobrains.app.logger.error(u"Failed saving file metadata: %s\n%s: %s" % (filename, type(e).__name__, e.message))
            os.remove(file_path)

        return self


class File(poobrains.auth.NamedOwned):

    form_add = UploadForm
    form_edit = UploadForm
    path = None
    extension_whitelist = set(['*'])

    filename = poobrains.storage.fields.CharField()

    class Meta:

        modes = collections.OrderedDict([
            ('add', 'create'),
            ('teaser', 'read'),
            ('full', 'read'),
            ('raw', 'read'),
            ('inline', 'read'),
            ('edit', 'update'),
            ('delete', 'delete')
        ])

    def __init__(self, *args, **kwargs):

        super(File, self).__init__(*args, **kwargs)
        self.path = os.path.join(poobrains.app.site_path, 'upload', self.__class__.__name__.lower())

    def __setattr__(self, name, value):

        if name == 'filename' and isinstance(value, basestring):
            value = werkzeug.utils.secure_filename(value)

        return super(File, self).__setattr__(name, value)

    @poobrains.auth.protected
    @poobrains.helpers.themed
    def view(self, mode=None, handle=None):

        if mode == 'raw':
            
            response = flask.send_from_directory(self.path, self.filename)
            response.headers['Content-Disposition'] = u'filename="%s"' % self.filename
            
            # Disable "public" mode caching downstream (nginx, varnish) in order to hopefully not leak restricted content
            response.cache_control.public = False
            response.cache_control.private = True

            return response
        
        else:
            return poobrains.helpers.ThemedPassthrough(super(File, self).view(mode=mode, handle=handle)) # FIXME: themed and protected called twice


    def delete_instance(self, *args, **kwargs):

        if super(File, self).delete_instance(*args, **kwargs):
            try:
                os.remove(os.path.join(self.path, self.filename))
            except OSError as e:
                flask.flash("Could not delete %s '%s'." % (self.__class__.__name__, self.filename))


class Image(File):
    extension_whitelist = set(['gif', 'jpg', 'png', 'svg'])

class Audio(File):
    extension_whitelist = set(['mp3', 'flac', 'ogg', 'wav'])

class Video(File):
    extension_whitelist = set(['mp4', 'webm', 'ogg'])

# setup upload routes for "raw" mode

for cls in [File] + File.children():
    rule = os.path.join("/upload/", cls.__name__.lower(), '<handle>')
    poobrains.app.site.add_view(cls, rule, mode='raw')

#    poobrains.app.register_blueprint(poobrains.app.site)
